<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数的作用域 数组 字符串]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[javascript 关于数组 字符串的简单操作 需时长默记 函数的作用域 / 变量的作用域：变量作用的范围 全局作用域 (全局变量)执行完函数，里面的内存不会清空 函数作用域 (局部作用域)局部变量函数执行完，里面的变量就都清空了； 临时变量只用一次在函数执行是开辟空间，执行完就释放掉了 数组一组相关的数据PS： var months =[1,2,3,4,5,6,7,8,9,10,11,12] var months = new Array; 元素 元素下标 在数组中 标识；下标 从0开始访问 变量名字 数组的长度 数组中元素的个数 // 谈到对象 就有属性和方法 数组元素的 增删改查length array.length push 在数组中最后追加一个元素。 推 ，放 array.push(&quot;!&quot;) pop 删除最后一个数组元素 array.pop shift 删除第一个数组元素 array.shift unshift 插入到第一个数组元素 array.unshift(&quot;!&quot;)中间位置 移除 / 添加splice(起始位置，元素的个数) 删除 第一个参数是从哪个位置开始 (开始删) ，第二个参数是删除的个数 splice(3,3) 从第3个位置开始，删除包括3开始的3个数 splice(array.length-1,1) 删除倒数第一个 中间用逗号隔开，例如 splice(1,2); splice(插入元素起始位置，0，[插入元素]) 插入 bbb.array(1,2,”charu”); 上面的这里：1表示当前插入的位置是1 2表示删除包含位置1的2个数 charu 表示在位置1插入”charu” 继续“查询 ”console.log(month[3]);下标查询 一段数据的查询： slice 都是位置months.slice(起始位置，结束位置-1)months.slice(3,8) 3-8的数组元素 返回结果还是一个数组。 返回下标为3，到8，但是不包含8的数组元素 slice (1,1); 查询1开始 查询第一个位置的 join (“-“); 用 - 连接数据 / 即转变成字符串 var result=months.slice(3.6); 返回一段数据的结果 3位置 到 6位置-1 var result=months.join(“-“) 用”-“让数组进行连接 reverse();反转 months.reverse() toString(); 用逗号继续连接各个数组 逻辑值转换为字符串 并返回结果； conact(); 用于返回 连接两个或多个数组 arrayObject.conact(arrayX,arrayX) arrayX可以是具体的值 也可以是数组对象 var a = [1,2,3]; a.concat(4,5); 输出结果是 1,2,3,4,5 1234var a=[1,2];var b=[3,4]; var e=["sd","ef","jk"]var c=a.concat(b,e) sort(0) 排序 比较大小 升序； (O_o)??↓ 降序 12345678var j=[1,2,3,4];j.sort();j.sort.reverse() //达成降序效果 或者j.sort(function(a,b)&#123; return b-a;&#125;) 字符串 String“abc”. 加点以后是 字符串对象 不是单纯的字符串了哦~ ####### 属性:length 包含字符的个数 abc.length ####### 方法: new string() 定义一个新的字符串 charAt 字符串也是从0开始的 aa.charAt(index) index 必需。表示字符串中某个位置的数字，即字符在字符串中的下标。 返回单个的元素值 concat 连接字符串 但是不影响原字符串 var result3=str+1; //连接作用 indexOf() 检索字符串。返回值 -1：未检索到； 0 ：第一位开始 indexOf(“检索当前内容是否在字符串中存在”) replace() 替换位置； 里面两个参数 search() 检索与正则表达式相匹配的值 slice(start,end) 提取字符串的片段，并在新的字符串中返回被提取的部分 split() 把字符串分割为字符串数组 括号内填写 需要用哪个符号来分开； 1234var str1="a1b1c1d1e";str1.split("1");输出： ["a","b","c"] 1234var str2="abcdef";str2.split("");输出： ["a","b","c","d","e","f"] substr() 从起始索引号提取字符串中指定数目的字符 str.substr(4,5); 从位置4开始，提取 1 2 3 4 5， 并返回一个新的字符串 但是不改变原字符串 str.substr(4) 从位置4开始 返回截止末位所有的字符 substring() 提取字符串中两个指定的索引号之间的字符 str.substring(4,6) 和slice 同理 都是end位置 -1； 需要查找 slice , substr , substring 的区别]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序 mock 封装记录]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F-mock-%E5%B0%81%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.本地创建 mock 数据2.使用 easy-mock 创建线上假数据并使用 一.本地创建 mock 数据 1.在 utils 下,创建 ajax.js ,即可在本地创建 mock 假数据, 如果要进行真数据开发,将 debug 设置为 false1234567891011121314151617181920212223242526272829303132333435363738394041const debug = true // debug = 开发模式const baseUrl = "http://baidu.com"const Mock = require('./mock-min.js')var ajax = (url) =&gt; &#123; wx.showLoading(&#123; title: '加载中', &#125;) return new Promise(function (s, f) &#123; // s代表成功 f代表失败 if (debug) &#123; //mock switch (url) &#123; // 三排商品数据 case "/user": var data = Mock.mock(&#123; "userlist|15":[ &#123; "subid|+1":1101, "img":"http://oano.cn/mockimg/31.png", "title":"@ctitle(2,4)" &#125; ] &#125;) s(&#123; data &#125;) break &#125; // 数据加载出来后,将数据隐藏 wx.hideLoading() &#125; else &#123; //真实 request 请求 wx.request(&#123; url: baseUrl + url, success: function (res) &#123; s(res) &#125; &#125;) &#125; &#125;)&#125;module.exports = &#123; ajax&#125; 2.其他页面可以直接调用 例如在 home/js 中1const $ = require('../../utils/ajax.js') 3.home.js 使用123456$.ajax("/user").then(res =&gt; &#123; // console.log(res.data.advList) this.setData(&#123; pageNames: res.data.userlist &#125;) &#125;) 二.使用 easy-mock 创建数据并使用登录网址 easy-mock 登录地址 1.在 utils 下创建 ajax.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const constant = require('../config/constant.js')const _ = require('../utils/simba.js')var ajax = (url, data, method="get") =&gt; &#123; wx.showLoading(&#123; title: '加载中', &#125;) console.log("请求了"+url,"参数是"+JSON.stringify(data)) return new Promise((success, f) =&gt; &#123; // s代表成功 f代表失败 wx.request(&#123; method, // 通过默认方式,默认是 get data, url: constant.BASE_URL + url, success, complete() &#123; wx.hideLoading() &#125; &#125;) &#125;)&#125; //腾讯 apivar getCityName = (longitude, latitude)=&gt;&#123; return new Promise((res,fail)=&gt;&#123; wx.request(&#123; url: 'https://apis.map.qq.com/ws/geocoder/v1', data: &#123; key: '2TDBZ-DTK3X-MO64M-7GQWJ-QUJBS-EPBZ5', location: latitude + ',' + longitude &#125;, success: result =&gt; &#123; res(result.data.result.address_component) // res = res.data.result.address_component // this.setData(&#123; // city: res.province + res.city + res.district + res.street + res.street_number // &#125;) &#125; &#125;) &#125;)&#125; //百度apivar getCityNameBD = (longitude, latitude) =&gt; &#123; return new Promise((res, fail) =&gt; &#123; wx.request(&#123; url: 'http://api.map.baidu.com/reverse_geocoding/v3', data: &#123; ak: 'krEFk5Dq5eClQGQ3iG12xoSlOvpoHsb0', output: 'json', coordtype: 'wgs84ll', location: latitude + ',' + longitude &#125;, success: result =&gt; &#123; console.log(result) res(result.data.result.addressComponent) &#125; &#125;) &#125;)&#125;module.exports = &#123; ajax, getCityName, getCityNameBD&#125; 2.根目录创建 config 文件夹 并在里创建 constant.js1234567const DEBUG = true // debug = 开发模式const BASE_URL = "https://easy-mock.com/mock/5d887e56c030f85c978d0c1f/leftmenu" // mock网址module.exports = &#123; DEBUG, BASE_URL // 导出&#125; 3.使用 例如在 menu.js 中1const $ = require(&apos;../../utils/ajax.js&apos;) 4. menu.js 中12345$.ajax("/v2/user/logout").then(res =&gt; &#123; this.setData(&#123; typelist: res.data.typelist &#125;) &#125;) 自此, mock 就可以轻松调取了,详细参考 Promise封装 yanpin 两个小程序细节]]></content>
      <categories>
        <category>mock</category>
      </categories>
      <tags>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.nextTick()方法的使用详解（简单明了）]]></title>
    <url>%2F2019%2F09%2F27%2Fvue-nextTick-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E7%AE%80%E5%8D%95%E6%98%8E%E4%BA%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简单理解: dom 更新结束之后执行回调, 但是自己却不能进行双向绑定的切换,所以需要执行 this.nextTick() 来进行更新,这里格外要注意 this 指向! 什么是Vue.nextTick()？？ 定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码； 理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class="hello"&gt; &lt;div&gt; &lt;button id="firstBtn" @click="testClick()" ref="aa"&gt;&#123;&#123;testMsg&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; testMsg:"原始值", &#125; &#125;, methods:&#123; testClick:function()&#123; let that=this; that.testMsg="修改后的值"; console.log(that.$refs.aa.innerText); //that.$refs.aa获取指定DOM，输出：原始值 &#125; &#125;&#125;&lt;/script&gt; 使用 this.$nextTick() 123456789methods:&#123; testClick:function()&#123; let that=this; that.testMsg="修改后的值"; that.$nextTick(function()&#123; console.log(that.$refs.aa.innerText); //输出：修改后的值 &#125;); &#125;&#125; 注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM， 什么时候需要用的Vue.nextTick()？？ 1、Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进 Vue.nextTick() 的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。 123456created()&#123; let that=this; that.$nextTick(function()&#123; //不使用this.$nextTick()方法会报错 that.$refs.aa.innerHTML="created中更改了按钮内容"; //写入到DOM元素 &#125;);&#125;, 2、当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class="hello"&gt; &lt;h3 id="h"&gt;&#123;&#123;testMsg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; testMsg:"原始值", &#125; &#125;, methods:&#123; changeTxt:function()&#123; let that=this; that.testMsg="修改后的文本值"; //vue数据改变，改变dom结构 let domTxt=document.getElementById('h').innerText; //后续js对dom的操作 console.log(domTxt); //输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的 if(domTxt==="原始值")&#123; console.log("文本data被修改后dom内容没立即更新"); &#125;else &#123; console.log("文本data被修改后dom内容被马上更新了"); &#125; &#125;, &#125;&#125;&lt;/script&gt; 正确的用法是：vue改变dom元素结构后使用vue.$nextTick()方法来实现dom数据更新后延迟执行后续代码 1234567891011121314changeTxt:function()&#123; let that=this; that.testMsg=&quot;修改后的文本值&quot;; //修改dom结构 that.$nextTick(function()&#123; //使用vue.$nextTick()方法可以dom数据更新后延迟执行 let domTxt=document.getElementById(&apos;h&apos;).innerText; console.log(domTxt); //输出可以看到vue数据修改后并没有DOM没有立即更新， if(domTxt===&quot;原始值&quot;)&#123; console.log(&quot;文本data被修改后dom内容没立即更新&quot;); &#125;else &#123; console.log(&quot;文本data被修改后dom内容被马上更新了&quot;); &#125; &#125;);&#125;, 3、在使用某个第三方插件时 ，希望在vue生成的某些dom动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。 Vue.nextTick(callback) 使用原理： 原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序学习记录]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[学习小程序一周记录:截止目前时间,页面排序和简单逻辑已经没有问题,明天开始进行购物车逻辑学习,日常补充 js 基础 现代js 小程序开发框架 — 属性id class style hidden data-* bind* / catch* 数据绑定列表渲染条件渲染模板引用 import 可以引入 template 里的内容include母版代码块外的所有代码都引入 ，相当于拷贝到了我们的 include 的这里 响应式像素 wxss =&gt; 尺寸单位 rpx | 样式导入 | 内联样式 | 选择器 特性样式 外联样式 在 .wxss 中, 通过 @import 引入其他 .！选择器 样式 class .intro #id #firstname element view 选择所有 view 组件 element,element view ,checkbox 选择文档的所有 view组件和checkbox组件 ::after view::after 在 view 后面插入内容 ::before view:;before !important style id .class element wxs 页面生命周期| | || —- | —- ||onLoad | 页面初次加载，微信会派发 onLoad事件 ||onShow | 一般我们是在 onLoad 和 onShow 里请求我们的服务器数据||onReady | 从服务器拿到的数据已经回来了，||onHide ||onUnload | 页面路由 所有的页面全部由框架进行管理，框架以栈的形式，维护了我们的小程序页面 路由方式： 初始化(新页面入栈) 2.打开新页面(新页面入栈)调用APIwx. navigateTo 或使用组件 3.页面重定向当前页面出栈，新页面入栈， 调用API wx.redirectTo 或使用组件 4.页面返回页面不断出栈，直到页面目标返回页，新页面入栈调用API wx.navigateBack 或使用组件 或左上角按钮 5.Tab切换页面全部出栈，只留下新的Tab页面调用API wx.switchTab 或使用组件 6.重加载页面全部出栈，只留下新的页面调用API wx.reLaunch 或使用组件 事件bindtap 基础知识:冒泡事件 如何实现 view容器组件是视图层的基本组成单元 组件自带一些功能与微信风格的样式 一个组件通常包括:开始标签和结束标签,属性用来修饰这个组件,内容在两个标签之内视图容器,媒体组件,地图,开放能力,画布,基础内容,表单组件,导航 view scroll-view swiper movable-view cover-view 滚动容器组件 轮播组件 可支持移动和缩放的组件 可以盖住原生组件 wx:for列表渲染中的 wx:key =” this “ 代表我们当前元素,this 的使用只能是字符串或者数字的元素的数组 四种基本元素组件: icon 官方图标 text \n 换行 selectable rich-text 富文本 progress 进度条 表单组件 button 按钮 default mini checkbox 多选框 form 表单 input 输入框 label 标签 与表单控件,关联在一起, picker 选择控件 - 主动触发,从底部弹起来 的滚动选择器[类似选择地区] picker-view 嵌在页面内的选择控件 radio 单选 switch 开关 text-area 多行文本框 12345bindfn:function()&#123;if(e.detail.value=='123')&#123;wx.hideKeyboard( ) &#125;&#125; 如果是一个 checkbox 的时候我们可以通过修改 swith的type =”checkbox” , 可以绑定 change 事件 媒体组件 - 以下都没有看: https://www.bilibili.com/video/av23470615/?p=51| 媒体组件 | || —- | —- || audio | 音频组件 ||camera |相机组件||image |图片组件||video |视频组件||live-player| 实时播放组件||live-pusher | 实时录制组件| 微信APIwx.on 监听我们某个api事件的接口Object参数 success成功 fail失败 complete完成()不论失败与否wx.get/wx.set 直调函数:指在我们程序运行的时候,立即运行的一个被调函数回调函数:在程序运行之后,回头再去执行的被调函数 网络请求wx.request 实例中 点击删除,删除下标对应的整个元素, 需要先绑定下标, 使用 data-id = this.data.items.splice(e.currentTarget.dataset.id,1) 即可 4 5 讲中 simba.js 关于一些原生 JS 的扩展和实现 ,可以参考 [https://gitee.com/shendusimba/simbajs] mock.min.js 关于生成假数据方便调用 使用 easy-mock 封装 mock开发环境或者 线上调用接口的js 并使用promise优化,将异步操作,由嵌套转变为链式 6 7 8 讲中 swiper 1. 做轮播图 2. 做滑动切换的效果 [t_swiper] v:if=”false“ 通过点击控制 为true 或者 true tabBar底部菜单切换 使用 iconfont png图标需要在 app.json 中进行配置 跳转路由使用 wx.swithTab 11 12 讲扫一扫是为了更快捷的操作通过大分类加载二级分类及商品的逻辑测试图片地址:http://oano.cn/mockimg/1.webp 白天任务,1.switch 代表多个if进行判断 o 练习:https://zh.javascript.info/switch2.查询forEach 学习 o3.抽空巩固js基础 数组 字符串等 = 晚上整 {item.price.toFixed(2)} //保留两位小数 parseInt( ) // 转变成数字 var arr = [1,2,3,4,5,5,5,4,3,2,2,22,2,] console.log(arr.slice(0,6)) concat() stringify() 获取位置,选择当前位置,用到 api 的位置 百度,高德开启服务api,可以快速通过 key,经,纬度来进行快速获取 早上来了继续看13 第34分钟 早上来了继续看16 第34分钟 第17集 抽空看 并应用于自己的小程序里https://www.bilibili.com/video/av56813745 抽空将 simba 课程的标题进行记录]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 解决 view 文字 过多 溢出的问题，超过行数后隐藏显示省略号]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%A7%A3%E5%86%B3-view-%E6%96%87%E5%AD%97-%E8%BF%87%E5%A4%9A-%E6%BA%A2%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E8%B6%85%E8%BF%87%E8%A1%8C%E6%95%B0%E5%90%8E%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[溢出隐藏溢出并使用… 多行文本 1234567891011.note_item text &#123; display: -webkit-box; font-size: 28rpx; color: #000000; line-height: 40rpx; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; text-overflow: ellipsis;&#125; 单行文本 12345678910.note2_item text &#123; display: block; font-size: 28rpx; color: #000000; line-height: 40rpx; height: 120rpx; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; tip:必须要有宽度]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中修改checkbox的样式]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BF%AE%E6%94%B9checkbox%E7%9A%84%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[详细列出 checkbox 默认属性 效果图 1,wxml 代码12345&lt;checkbox-group&gt; &lt;label&gt; &lt;checkbox&gt;&lt;/checkbox&gt; &lt;/label&gt;&lt;/checkbox-group&gt; 2,wxss 代码12345678910111213141516171819202122checkbox .wx-checkbox-input &#123; width: 34rpx; height: 34rpx; border-radius: 50%;&#125;/*checkbox选中后样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked &#123; background: #0394F0; border-color:#0394F0;&#125;/*checkbox选中后图标样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked::before &#123; width: 20rpx; height: 20rpx; line-height: 20rpx; text-align: center; font-size: 22rpx; color: #fff; background: transparent; transform: translate(-50%, -50%) scale(1); -webkit-transform: translate(-50%, -50%) scale(1);&#125;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型和引用数据类型的区别]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[简单阐述数据类型 1、栈(stack)和堆（heap）Javascript 包含两种不同类型的值：基本类型值 引用类型值； 基本类型值：指的是保存在栈内存的简单数据段。 引用类型值：指的是那些保存在堆内存的对象，意思是：变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值。 2、基本数据类型5 种常用类型：Number、 String、 Boolean、 Undefined、 Null ，基本数据类型的值是按值访问的，就是说我们可以操作保存在变量中的实际的值 基本数据类型的赋值是简单赋值，是存放在栈内存里的1234var fo = 10;var bar = fo; // 将 fo 的值(10) 赋值给 bar ， bar = 10 。fo = 2; // fo 的值声明为 2console.log(fo, bar); //fo = 2 ,b = 10 图解：从上面我们可以得知，当我改变fo中的数据时，bar中数据没有发生变化。 3、引用数据类型引用数据类型：Object123456var fo = &#123; a: 10 &#125;;var bar = fo; fo.a = 2; console.log(fo.a, bar.a); //fo = 2 ,b = 2 图解： 从上面我们可以得知，当我改变fo中的数据时，bar中数据也发生了变化。当使用fo这个变量时，js解释器会通过bar存放的内存地址，找到内存中的相应地址，将其中的值取出来返回.]]></content>
      <tags>
        <tag>Javascript基础</tag>
      </tags>
  </entry>
</search>
